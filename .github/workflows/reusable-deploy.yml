# Reusable Workflow: Async Deployment with Polling
# This workflow can be called from other repositories
# Usage: In the repository that wants to use this workflow, call this reusable workflow

name: Reusable Async Deployment

on:
  workflow_call:
    inputs:
      autodeploy_url:
        description: 'Autodeploy server URL'
        required: true
        type: string
      deploy_key:
        description: 'Key to authenticate the deployment'
        required: true
        type: string
      repository:
        description: 'Repository name to deploy'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA to deploy'
        required: true
        type: string
      commit_author:
        description: 'Commit author'
        required: true
        type: string
    secrets:
      KEY_FILE_FOR_DEPLOY:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Deploy to Server (Async + Polling)
        env:
          AUTODEPLOY_URL: ${{ inputs.autodeploy_url }}
          KEY_FILE_FOR_DEPLOY: ${{ secrets.KEY_FILE_FOR_DEPLOY }}
          REPOSITORY: ${{ inputs.repository }}
          COMMIT_SHA: ${{ inputs.commit_sha }}
          COMMIT_AUTHOR: ${{ inputs.commit_author }}
        run: |
          set -e  # Exit if any command fails
          
          echo "üöÄ Starting deployment to production (async mode)..."
          echo "üìã Commit: ${COMMIT_SHA}"
          echo "üë§ Author: ${COMMIT_AUTHOR}"
          echo ""
          
          # ============================================
          # STEP 1: Start deployment in background
          # ============================================
          
          echo "üì§ Starting deployment in background..."
          deployment_url="https://${AUTODEPLOY_URL}?repo=${REPOSITORY}&key=${KEY_FILE_FOR_DEPLOY}"
          echo "   URL: ${deployment_url}"
          echo ""
          
          init_response=$(curl -X POST \
            -H "Content-Type: application/json" \
            -d '{
              "key": "'"${KEY_FILE_FOR_DEPLOY}"'",
              "run_in_background": true,
              "commit": {
                "sha": "'"${COMMIT_SHA}"'",
                "author": "'"${COMMIT_AUTHOR}"'"
              }
            }' \
            -w "\nHTTP_CODE:%{http_code}\nCURL_EXIT:%{exitcode}" \
            -s -S \
            --show-error \
            --connect-timeout 30 \
            --max-time 60 \
            "${deployment_url}" 2>&1)
          
          curl_exit_code=$?
          
          # Extract HTTP code and curl exit code from response
          http_code=$(echo "$init_response" | grep "HTTP_CODE:" | cut -d: -f2 || echo "")
          curl_exit_from_response=$(echo "$init_response" | grep "CURL_EXIT:" | cut -d: -f2 || echo "")
          body=$(echo "$init_response" | sed '/HTTP_CODE:/d' | sed '/CURL_EXIT:/d')
          
          # Handle curl errors with detailed diagnostics
          if [ $curl_exit_code -ne 0 ]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ùå Error starting deployment"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üîç Diagnostic Information:"
            echo "   - curl exit code: $curl_exit_code"
            echo "   - URL attempted: ${deployment_url}"
            echo "   - Repository: ${REPOSITORY}"
            echo ""
            
            # Provide specific error messages based on curl exit code
            case $curl_exit_code in
              6)
                echo "üî¥ Error: Could not resolve host '${AUTODEPLOY_URL}'"
                echo "   This usually means DNS resolution failed."
                echo "   Check that AUTODEPLOY_URL is correct: ${AUTODEPLOY_URL}"
                ;;
              7)
                echo "üî¥ Error: Failed to connect to '${AUTODEPLOY_URL}'"
                echo "   This usually means the server is down or unreachable."
                echo "   Check if the autodeploy server is running."
                ;;
              28)
                echo "üî¥ Error: Operation timed out after 60 seconds"
                echo "   The server took too long to respond."
                echo ""
                echo "   Possible causes:"
                echo "   - Server is overloaded or slow"
                echo "   - Network connectivity issues"
                echo "   - Server may be processing the request but taking too long"
                echo ""
                echo "   üí° Try checking the server status manually or increase --max-time"
                ;;
              52)
                echo "üî¥ Error: Empty reply from server"
                echo "   The server closed the connection without sending a response."
                ;;
              56)
                echo "üî¥ Error: Failure receiving network data"
                echo "   Network connection was interrupted."
                ;;
              *)
                echo "üî¥ Error: curl failed with exit code $curl_exit_code"
                echo "   See curl documentation for error code meaning."
                ;;
            esac
            
            echo ""
            echo "üìã Raw response:"
            echo "$body" | head -50
            
            exit 1
          fi
          
          # Verify the response is valid (http_code already extracted above)
          if [ -z "$http_code" ] || [ "$http_code" = "" ]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ùå Error: Could not extract HTTP code from response"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üìã Raw response:"
            echo "$init_response"
            exit 1
          fi
          
          if [ "$http_code" != "201" ]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ùå Error starting deployment (HTTP $http_code)"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üìã Server response:"
            echo "$body" | jq '.' 2>/dev/null || echo "$body"
            echo ""
            echo "üí° HTTP Status Codes:"
            echo "   201 = Created (expected)"
            echo "   400 = Bad Request (check request parameters)"
            echo "   401 = Unauthorized (check deploy key)"
            echo "   500 = Internal Server Error (server issue)"
            exit 1
          fi
          
          # Extract run_id
          run_id=$(echo "$body" | jq -r '.run_id // empty')
          if [ -z "$run_id" ] || [ "$run_id" = "null" ]; then
            echo "‚ùå Could not get run_id from response"
            echo "Response:"
            echo "$body" | jq '.' || echo "$body"
            exit 1
          fi
          
          echo "‚úÖ Deployment started"
          echo "   Run ID: $run_id"
          echo ""
          
          # Show monitoring URLs if available
          status_url=$(echo "$body" | jq -r '.monitoring.status_url // empty')
          logs_url=$(echo "$body" | jq -r '.monitoring.logs_url // empty')
          if [ -n "$status_url" ]; then
            echo "üìä Monitoring URLs:"
            echo "   Status: $status_url"
            [ -n "$logs_url" ] && echo "   Logs: $logs_url"
            echo ""
          fi
          
          # ============================================
          # STEP 2: Polling loop to check status
          # ============================================
          
          max_wait=2700  # 45 minutes (must match job timeout-minutes)
          poll_interval=5  # Check every 5 seconds
          progress_interval=30  # Show progress every 30 seconds
          start_time=$(date +%s)
          
          echo "‚è≥ Waiting for deployment to complete..."
          echo "   - Polling every ${poll_interval}s"
          echo "   - Max timeout: ${max_wait}s ($(($max_wait / 60)) minutes)"
          echo "   - Run ID: $run_id"
          echo ""
          
          last_progress_time=0
          last_step_seen=-1
          last_phase_seen=""
          
          while true; do
            elapsed=$(($(date +%s) - start_time))
            
            # Check timeout
            if [ $elapsed -ge $max_wait ]; then
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "‚è±Ô∏è  Timeout waiting for deployment (${max_wait}s)"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo ""
              echo "The deployment may still be running on the server."
              echo "Run ID: $run_id"
              echo ""
              echo "üí° To check status manually:"
              echo "   curl 'https://${AUTODEPLOY_URL}?deployment_status=true&previous_run_id=${run_id}'"
              exit 1
            fi
            
            # Query deployment status
            status_url="https://${AUTODEPLOY_URL}?deployment_status=true&previous_run_id=${run_id}"
            status_response=$(curl -s -S \
              --show-error \
              --connect-timeout 10 \
              --max-time 30 \
              "${status_url}" \
              2>&1)
            
            curl_status_exit=$?
            
            # If there's an error querying, continue (may be temporary)
            if [ $curl_status_exit -ne 0 ]; then
              if [ $((elapsed - last_progress_time)) -ge $progress_interval ]; then
                echo "‚ö†Ô∏è  Error checking status (${elapsed}s)"
                case $curl_status_exit in
                  28)
                    echo "   Reason: Request timeout"
                    ;;
                  7)
                    echo "   Reason: Could not connect to server"
                    ;;
                  6)
                    echo "   Reason: DNS resolution failed"
                    ;;
                  *)
                    echo "   Reason: curl exit code $curl_status_exit"
                    ;;
                esac
                echo "   Retrying..."
                last_progress_time=$elapsed
              fi
              sleep $poll_interval
              continue
            fi
            
            # Parse status from JSON
            status=$(echo "$status_response" | jq -r '.status // "UNKNOWN"')
            
            # If still running
            if [ "$status" = "RUNNING" ]; then
              current_phase=$(echo "$status_response" | jq -r '.current_phase // "unknown"')
              current_step=$(echo "$status_response" | jq -r '.current_step // "unknown"')
              total_steps=$(echo "$status_response" | jq -r '.steps | length // 0')
              
              # Show progress immediately when step or phase changes
              step_changed=false
              phase_changed=false
              current_step_num=""
              
              if [ "$current_step" != "unknown" ] && [ "$current_step" != "null" ]; then
                # Ensure we're comparing numbers
                current_step_num=$current_step
                if [ "$current_step_num" -ne "$last_step_seen" ]; then
                  step_changed=true
                fi
              fi
              
              if [ "$current_phase" != "unknown" ] && [ "$current_phase" != "null" ] && [ "$current_phase" != "$last_phase_seen" ]; then
                phase_changed=true
              fi
              
              # Show progress immediately on change OR periodically
              if [ "$step_changed" = "true" ] || [ "$phase_changed" = "true" ] || [ $((elapsed - last_progress_time)) -ge $progress_interval ]; then
                phase_display=$(echo "$current_phase" | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                
                # Show step number (1-indexed) instead of step ID (0-indexed)
                if [ "$current_step" != "unknown" ] && [ "$current_step" != "null" ] && [ -n "$current_step_num" ]; then
                  step_number=$(($current_step_num + 1))
                  echo "‚è≥ Running... (${elapsed}s) | Phase: $phase_display | Step ${step_number}/${total_steps}"
                  last_step_seen=$current_step_num
                else
                  echo "‚è≥ Running... (${elapsed}s) | Phase: $phase_display | Completed: ${total_steps}"
                fi
                
                # Show the actual command being executed when step changes
                if [ "$step_changed" = "true" ] && [ -n "$current_step_num" ] && [ "$total_steps" -gt 0 ]; then
                  # Get the command from the currently executing step
                  current_command=$(echo "$status_response" | jq -r ".steps[$current_step_num].command // empty")
                  if [ -n "$current_command" ]; then
                    echo "   ‚Üí $current_command"
                  fi
                fi
                
                last_progress_time=$elapsed
                last_phase_seen=$current_phase
              fi
              
              sleep $poll_interval
              continue
            fi
            
            # ============================================
            # STEP 3: Process final result
            # ============================================
            
            # If completed successfully
            if [ "$status" = "SUCCESS" ]; then
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "‚úÖ Deployment completed successfully!"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo ""
              
              total_steps=$(echo "$status_response" | jq -r '.steps | length // 0')
              started_at=$(echo "$status_response" | jq -r '.started_at // "unknown"')
              completed_at=$(echo "$status_response" | jq -r '.completed_at // "unknown"')
              
              echo "üìà Summary:"
              echo "   - Total steps: ${total_steps}"
              echo "   - Started: ${started_at}"
              echo "   - Completed: ${completed_at}"
              echo "   - Total time: ${elapsed}s"
              echo ""
              
              # Show all completed steps with clear numbering
              echo "üìã Completed steps:"
              echo "$status_response" | jq -r '.steps[] | "   ‚úì Step \(.id + 1): \(.command) [\(.phase)] (exit: \(.exit_code))"' || true
              
              exit 0
            fi
            
            # If failed
            if [ "$status" = "FAILED" ]; then
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "‚ùå Deployment failed!"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo ""
              
              failed_step=$(echo "$status_response" | jq -r '.failed_step // {}')
              
              if [ "$failed_step" != "{}" ] && [ "$failed_step" != "null" ]; then
                step_id=$(echo "$status_response" | jq -r '.failed_step.step_id // "-1"')
                phase=$(echo "$status_response" | jq -r '.failed_step.phase // "unknown"')
                command=$(echo "$status_response" | jq -r '.failed_step.command // "unknown"')
                exit_code=$(echo "$status_response" | jq -r '.failed_step.exit_code // "unknown"')
                
                # Check if it's a timeout (exit code 124)
                is_timeout=false
                if [ "$exit_code" = "124" ]; then
                  is_timeout=true
                fi
                
                phase_display=$(echo "$phase" | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                
                # Show all steps up to the one that failed (for context)
                echo "üìã Steps executed (before failure):"
                all_steps=$(echo "$status_response" | jq -r '.steps // []')
                if [ "$all_steps" != "[]" ] && [ "$all_steps" != "null" ]; then
                  echo "$status_response" | jq -r '.steps[] | "   Step \(.id + 1): \(.command) [\(.phase)] (exit: \(.exit_code // "N/A"))"' || true
                fi
                
                echo ""
                echo "üî¥ Failed step:"
                step_number=$(($step_id + 1))
                echo "   Step ${step_number}: $command"
                echo "   Phase: $phase_display"
                echo "   Exit code: $exit_code"
                
                if [ "$is_timeout" = "true" ]; then
                  echo "   ‚è±Ô∏è  TIMEOUT detected (command exceeded time limit)"
                fi
                
                echo ""
                echo "üìã Command output (last 30 lines):"
                echo "$status_response" | jq -r '.failed_step.output[]?' | tail -30 | sed 's/^/     /'
              else
                error_message=$(echo "$status_response" | jq -r '.error_message // "Unknown error"')
                echo "üî¥ Error: $error_message"
              fi
              
              echo ""
              echo "üí° For more details, check server logs."
              exit 1
            fi
            
            # Unknown status
            echo ""
            echo "‚ö†Ô∏è  Unknown status: $status"
            echo ""
            echo "üìã Full response:"
            echo "$status_response" | jq '.' || echo "$status_response"
            exit 1
          done

